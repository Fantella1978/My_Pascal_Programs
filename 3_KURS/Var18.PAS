{ Программа отделения корней функции f(x)=x^2-sin(x)-0.25=0 методом
 последовательного перебора}
Uses crt;
Var
   Xn, Xk, dx, y,
   x :real;
   f,i:integer;
Begin
     clrscr;
     writeln('Программа отделения корней уравнения методом последовательного перебора.');
     writeln;
     {Ввод исходных данных}
     write('Введите нижнюю границу интервала Xn =');
     readln(Xn);
     write('Введите верхнюю границу интервала Xk =');
     readln(Xk);
     write('Введите шаг расчета dx =');
     readln (dx);
     writeln;
     {Расчет начального значения функции}
     x:= Xn; y:= x*x-SIN(x)-0.25;
     {Установка f - флага знака ф-ции y в зависимости от полученных значений}
     if (y < 0) then
        f:= 0
     else
         f:= 1;
     {Обнуление i - флага наличия корней уравнения}
     i:= 0;
     x:= Xn+dx;
     while (x < Xk) do
     begin
       {Расчет ф-ции y}
       y:= x*x-SIN(x)-0.25;
       {Проверка смены ф-цией y знака}
       if ((y < 0) AND (f = 1) OR (y > 0) AND (f = 0)) then
       begin
           writeln('Корень уравнения x=', x-dx/2:6:2, ' с точностью E =',
                           dx/2:6:4);
           {В случае, если знак изменился, меняется значение флага f на
            противоположное (f принимает всего два значения 0 и 1)}
           f:= ABS(f-1);
           {Если знак ф-ции изменился хоть один раз, то найден корень
           уравнения и флагу i присваивается значение 1}
           i:= 1
       end;
       x:=x+dx
     end;
{ Если корни уравнения не найдены (i=0), то выводится соответствующая
  информация }
  if (i = 0) then
     begin
          writeln('В интервале (', Xn, ',', Xk, '), при расчетах с шагом dx =', dx);
          writeln('корни уравнения не найдены.');
     end;
END.

